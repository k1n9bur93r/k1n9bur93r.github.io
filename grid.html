<!DOCTYPE html>
<html>
<head>
    <title>Ray Animation System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
    <style>
        body {
            margin: 20px;
            font-family: Arial, sans-serif;
            background: #f0f0f0;
        }
        .container {
            display: flex;
            gap: 20px;
        }
        .grid-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            width: 400px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input, select {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            background: #4eace1;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #3d8bb3;
        }
        button.active {
            background: #f5686b;
        }
        .timeline {
            margin-top: 20px;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 4px;
        }
        .timeline-item {
            background: #f8f8f8;
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .color-preview {
            width: 20px;
            height: 20px;
            display: inline-block;
            border: 1px solid #ddd;
            vertical-align: middle;
        }
        #jsonOutput {
            width: 100%;
            height: 100px;
            margin-top: 10px;
            font-family: monospace;
        }
        .coordinate-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        .selection-mode {
            padding: 10px;
            margin: 10px 0;
            background: #f8f8f8;
            border-radius: 4px;
            text-align: center;
            display: none;
        }
        .selection-mode.active {
            display: block;
            background: #e8f4f8;
        }

        .shape-selector {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        .shape-option {
            aspect-ratio: 1;
            border: 2px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 5px;
        }
        .shape-option.selected {
            border-color: #4eace1;
            background: #e8f4f8;
        }
        .shape-preview {
            width: 100%;
            height: 100%;
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="grid-container">
            <!-- PIXI.js canvas will be inserted here -->
        </div>
            <!-- Previous HTML structure remains... -->
            <div class="form-group">
                <label>Cell Shape:</label>
                <select id="shapeSelect" class="shape-select">
                    <!-- Options will be populated automatically -->
                </select>
            </div>
        <div class="controls">
            <h2>Ray Creator</h2>
            
            <div class="coordinate-buttons">
                <button id="setOriginBtn" onclick="toggleSelectionMode('origin')">Set Origin</button>
                <button id="setTargetBtn" onclick="toggleSelectionMode('target')">Set Target</button>
            </div>
            
            <div id="selectionMode" class="selection-mode">
                Click on the grid to set the <span id="selectionType"></span>
            </div>

            <div class="form-group">
                <label>Head Size:</label>
                <input type="number" id="headSize" value="1" min="1" max="5">
                
                <label>Origin Coordinates:</label>
                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                    <input type="number" id="originX" value="0" min="0" placeholder="X">
                    <input type="number" id="originY" value="0" min="0" placeholder="Y">
                </div>
                
                <label>Target Coordinates:</label>
                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                    <input type="number" id="targetX" value="5" min="0" placeholder="X">
                    <input type="number" id="targetY" value="5" min="0" placeholder="Y">
                </div>
                
                <label>Head Color:</label>
                <input type="color" id="headColor" value="#ff0000">
                
                <label>Trail Color (leave empty for no trail):</label>
                <input type="color" id="trailColor" value="#ffcccc">
                
                <label>Duration (ms):</label>
                <input type="number" id="duration" value="1000" min="100">
                
                <label>Delay Before Start (ms):</label>
                <input type="number" id="delay" value="0" min="0">
            </div>
            
            <button onclick="previewRay()">Preview Ray</button>
            <button onclick="addToTimeline()">Add to Timeline</button>
            <button onclick="clearPreview()">Clear Preview</button>
            
            <h2>Timeline</h2>
            <div id="timeline" class="timeline"></div>
            
            <button onclick="playTimeline()">Play Timeline</button>
            <button onclick="clearTimeline()">Clear Timeline</button>
            <button onclick="exportTimeline()">Export Timeline</button>
            
            <h3>Timeline JSON</h3>
            <textarea id="jsonOutput" readonly></textarea>
        </div>
    </div>

    <script>
        //Shapes
        const ShapeLibrary = {
    square: {
        name: 'Square',
        draw: (graphics, size, color) => {
            graphics.beginFill(color);
            graphics.drawRect(0, 0, size, size);
            graphics.endFill();
        }
    },
    circle: {
        name: 'Circle',
        draw: (graphics, size, color) => {
            graphics.beginFill(color);
            graphics.drawCircle(size/2, size/2, size/2);
            graphics.endFill();
        }
    },
    rhombus: {
        name: 'Rhombus',
        draw: (graphics, size, color) => {
            graphics.beginFill(color);
            graphics.moveTo(size/2, 0);
            graphics.lineTo(size, size/2);
            graphics.lineTo(size/2, size);
            graphics.lineTo(0, size/2);
            graphics.closePath();
            graphics.endFill();
        }
    },
    triangle: {
        name: 'Triangle',
        draw: (graphics, size, color) => {
            graphics.beginFill(color);
            graphics.moveTo(size/2, 0);
            graphics.lineTo(size, size);
            graphics.lineTo(0, size);
            graphics.closePath();
            graphics.endFill();
        }
    },
    star: {
        name: 'Star',
        draw: (graphics, size, color) => {
            const points = 5;
            const outerRadius = size/2;
            const innerRadius = size/4;
            const cx = size/2;
            const cy = size/2;
            
            graphics.beginFill(color);
            graphics.moveTo(cx, cy - outerRadius);
            
            for(let i = 0; i < points * 2; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const angle = (i * Math.PI) / points;
                graphics.lineTo(
                    cx + radius * Math.sin(angle),
                    cy - radius * Math.cos(angle)
                );
            }
            
            graphics.closePath();
            graphics.endFill();
        }
    },
    trebleClef: {
        name: 'Treble Clef',
        draw: (graphics, size, color) => {
            const scale = size/100;
            graphics.beginFill(color);
            // Simplified treble clef path
            graphics.moveTo(60*scale, 10*scale);
            graphics.bezierCurveTo(
                60*scale, 40*scale,
                10*scale, 40*scale,
                10*scale, 70*scale
            );
            graphics.bezierCurveTo(
                10*scale, 90*scale,
                30*scale, 90*scale,
                30*scale, 70*scale
            );
            graphics.bezierCurveTo(
                30*scale, 50*scale,
                10*scale, 50*scale,
                10*scale, 30*scale
            );
            graphics.bezierCurveTo(
                10*scale, 10*scale,
                60*scale, 20*scale,
                60*scale, 50*scale
            );
            graphics.bezierCurveTo(
                60*scale, 80*scale,
                40*scale, 90*scale,
                20*scale, 90*scale
            );
            graphics.endFill();
        }
    },
    diamond: {
        name: 'Diamond',
        draw: (graphics, size, color) => {
            graphics.beginFill(color);
            graphics.moveTo(size/2, 0);
            graphics.lineTo(size, size/2);
            graphics.lineTo(size/2, size);
            graphics.lineTo(0, size/2);
            graphics.closePath();
            graphics.endFill();
        }
    },
    hexagon: {
        name: 'Hexagon',
        draw: (graphics, size, color) => {
            const sides = 6;
            const radius = size/2;
            const cx = size/2;
            const cy = size/2;
            
            graphics.beginFill(color);
            graphics.moveTo(
                cx + radius * Math.cos(0),
                cy + radius * Math.sin(0)
            );
            
            for (let i = 1; i <= sides; i++) {
                const angle = (i * 2 * Math.PI) / sides;
                graphics.lineTo(
                    cx + radius * Math.cos(angle),
                    cy + radius * Math.sin(angle)
                );
            }
            
            graphics.closePath();
            graphics.endFill();
        }
    }
};
 // Cells 
 // Cell class to manage shape and color
class Cell {
    constructor(x, y, size) {
        this.container = new PIXI.Container();
        this.container.x = x * (CELL_SIZE + CELL_SPACING);
        this.container.y = y * (CELL_SIZE + CELL_SPACING);
        this.size = size;
        this.graphics = new PIXI.Graphics();
        this.container.addChild(this.graphics);
        this.shape = 'square';
        this.color = 0x333333;
        this.draw();
        this.x = x;
        this.y = y;
    }

    setShape(shapeName) {
        this.shape = shapeName;
        this.draw();
    }

    setColor(color) {
        this.color = color;
        this.draw();
    }

    draw() {
        this.graphics.clear();
        const shape = ShapeLibrary[this.shape];
        if (shape) {
            shape.draw(this.graphics, this.size, this.color);
        }
    }
}

        // Grid configuration
        const GRID_WIDTH = 100;
        const GRID_HEIGHT = 75;
        const CELL_SIZE = 10;
        const CELL_SPACING = 1;

        // Selection mode state
        let selectionMode = null;
        let originPreview = null;
        let targetPreview = null;

        // Initialize PIXI Application
        const app = new PIXI.Application({
            width: GRID_WIDTH * (CELL_SIZE + CELL_SPACING),
            height: GRID_HEIGHT * (CELL_SIZE + CELL_SPACING),
            backgroundColor: 0x1a1a1a,
        });
        document.querySelector('.grid-container').appendChild(app.view);


        let cells = [];
const grid = new PIXI.Container();
app.stage.addChild(grid);

for (let y = 0; y < GRID_HEIGHT; y++) {
    cells[y] = [];
    for (let x = 0; x < GRID_WIDTH; x++) {
        const cell = new Cell(
            x ,
            y ,
            CELL_SIZE
        );
        
        cell.container.interactive = true;
        cell.container.buttonMode = true;
        cell.container.on('pointerdown', () => handleCellClick(cell));
        cell.container.on('pointerover', () => {
            if (selectionMode) {
                highlightCell(cell);
            }
        });
        cell.container.on('pointerout', () => {
            if (selectionMode) {
                unhighlightCell(cell);
            }
        });
        
        cells[y][x] = cell;
        grid.addChild(cell.container);
    }
}

        function highlightCell(cell) {
            const alpha = 0.3;
            cell.graphics.clear();
            cell.graphics.beginFill(selectionMode === 'origin' ? 0x00ff00 : 0xff0000, alpha);
            cell.graphics.drawRect(0, 0, CELL_SIZE, CELL_SIZE);
            cell.graphics.endFill();
        }

        function unhighlightCell(cell) {
            cell.graphics.clear();
            cell.graphics.beginFill(0x333333);
            cell.graphics.drawRect(0, 0, CELL_SIZE, CELL_SIZE);
            cell.graphics.endFill();
            
            // Restore previews if they exist
            if (originPreview && cell.x === originPreview.x && cell.y === originPreview.y) {
                cell.graphics.clear();
                cell.graphics.beginFill(0x00ff00, 0.5);
                cell.graphics.drawRect(0, 0, CELL_SIZE, CELL_SIZE);
                cell.graphics.endFill();
            }
            if (targetPreview && cell.x === targetPreview.x && cell.y === targetPreview.y) {
                cell.graphics.clear();
                cell.graphics.beginFill(0xff0000, 0.5);
                cell.graphics.drawRect(0, 0, CELL_SIZE, CELL_SIZE);
                cell.graphics.endFill();
            }
        }

        function handleCellClick(event) {
            if (!selectionMode) return;

            const cell = event;
            console.log(event);
            const x = cell.x;
            const y = cell.y;

            if (selectionMode === 'origin') {
                document.getElementById('originX').value = x;
                document.getElementById('originY').value = y;
                
                // Update origin preview
                if (originPreview) {
                    const oldCell = cells[originPreview.y][originPreview.x];
                    oldCell.graphics.clear();
                    oldCell.graphics.beginFill(0x333333);
                    oldCell.graphics.drawRect(0, 0, CELL_SIZE, CELL_SIZE);
                    oldCell.graphics.endFill();
                }
                originPreview = { x, y };
                
                cell.graphics.clear();
                cell.graphics.beginFill(0x00ff00, 0.5);
                cell.graphics.drawRect(0, 0, CELL_SIZE, CELL_SIZE);
                cell.graphics.endFill();
            } else if (selectionMode === 'target') {
                document.getElementById('targetX').value = x;
                document.getElementById('targetY').value = y;
                
                // Update target preview
                if (targetPreview) {
                    const oldCell = cells[targetPreview.y][targetPreview.x];
                    oldCell.graphics.clear();
                    oldCell.graphics.beginFill(0x333333);
                    oldCell.graphics.drawRect(0, 0, CELL_SIZE, CELL_SIZE);
                    oldCell.graphics.endFill();
                }
                targetPreview = { x, y };
                
                cell.graphics.clear();
                cell.graphics.beginFill(0xff0000, 0.5);
                cell.graphics.drawRect(0, 0, CELL_SIZE, CELL_SIZE);
                cell.graphics.endFill();
            }

            // Exit selection mode
            exitSelectionMode();
        }

        function toggleSelectionMode(mode) {
            if (selectionMode === mode) {
                exitSelectionMode();
            } else {
                enterSelectionMode(mode);
            }
        }

        function enterSelectionMode(mode) {
            selectionMode = mode;
            
            // Update UI
            document.getElementById('setOriginBtn').classList.toggle('active', mode === 'origin');
            document.getElementById('setTargetBtn').classList.toggle('active', mode === 'target');
            
            const selectionModeDiv = document.getElementById('selectionMode');
            selectionModeDiv.classList.add('active');
            document.getElementById('selectionType').textContent = mode === 'origin' ? 'origin point' : 'target point';
        }

        function exitSelectionMode() {
            selectionMode = null;
            
            // Update UI
            document.getElementById('setOriginBtn').classList.remove('active');
            document.getElementById('setTargetBtn').classList.remove('active');
            document.getElementById('selectionMode').classList.remove('active');
        }

        // Ray class definition
        class Ray {
            constructor(config) {
                this.headSize = config.headSize || 1;
                this.origin = config.origin;
                this.target = config.target;
                this.headColor = config.headColor;
                this.trailColor = config.trailColor;
                this.duration = config.duration;
                this.delay = config.delay || 0;
                this.currentPos = { ...this.origin };
                this.progress = 0;
                this.isActive = false;
                this.shape = config.shape || 'square';
            }

            update(delta) {
                if (!this.isActive) return false;
                this.progress += delta;
                const t = Math.min(this.progress / this.duration, 1);

                // Clear previous head position
                this.drawHead(this.currentPos, this.trailColor || 0x333333);

                // Calculate new position
                this.currentPos = {
                    x: Math.round(this.origin.x + (this.target.x - this.origin.x) * t),
                    y: Math.round(this.origin.y + (this.target.y - this.origin.y) * t)
                };

                // Draw new head position
                this.drawHead(this.currentPos, this.headColor);

                return t < 1;
            }

            drawHead(pos, color) {
                console.log(pos);
        const size = this.headSize;
        for (let dy = 0; dy < size; dy++) {
            for (let dx = 0; dx < size; dx++) {
                const x = pos.x + dx;
                const y = pos.y + dy;
                    console.log('check b4 draw')
                    console.log(`post compute x ${x}, post compute y ${y}`);
                    console.log(x >= 0 );
                    console.log( x < GRID_WIDTH );
                    console.log( y >= 0 );
                    console.log( y < GRID_HEIGHT);
                //if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                    console.log('drawing cell')
                    const cell = cells[y][x];
                    cell.setShape(this.shape);
                    cell.setColor(color);
               // }
            }
        }
    }

            start() {
                this.isActive = true;
                this.progress = 0;
                this.currentPos = { ...this.origin };
            }
        }

        // Timeline management
        let timeline = [];
        let activeRays = [];
        let isPlaying = false;
        let startTime = 0;


        const styles = `
            .shape-select {
                width: 100%;
                padding: 8px;
                margin-bottom: 10px;
                border: 1px solid #ddd;
                border-radius: 4px;
            }
        `;

        // Add this to your form group, replacing the shape-selector div
        const shapeSelectHtml = `
            <label>Cell Shape:</label>
            <select id="shapeSelect" class="shape-select">
                ${Object.keys(ShapeLibrary).map(shape => 
                    `<option value="${shape}">${ShapeLibrary[shape].name}</option>`
                ).join('')}
            </select>
        `;

        // Initialize shape selector UI
        function initializeShapeSelector() {
            const select = document.getElementById('shapeSelect');
            select.innerHTML=shapeSelectHtml;
            select.addEventListener('change', (e) => {
                currentShape = e.target.value;
            });
            // Initialize with first shape
            currentShape = Object.keys(ShapeLibrary)[0];
        }

        function createRayFromForm() {
            return new Ray({
                headSize: parseInt(document.getElementById('headSize').value),
                origin: {
                    x: parseInt(document.getElementById('originX').value),
                    y: parseInt(document.getElementById('originY').value)
                },
                target: {
                    x: parseInt(document.getElementById('targetX').value),
                    y: parseInt(document.getElementById('targetY').value)
                },
                headColor: parseInt(document.getElementById('headColor').value.slice(1), 16),
                trailColor: document.getElementById('trailColor').value ? 
                    parseInt(document.getElementById('trailColor').value.slice(1), 16) : false,
                duration: parseInt(document.getElementById('duration').value),
                delay: parseInt(document.getElementById('delay').value),
                shape: currentShape || 'square'
            });
        }

        function previewRay() {
            clearGrid();
            const ray = createRayFromForm();
            activeRays = [ray];
            ray.start();
            if (!isPlaying) {
                startTime = Date.now();
                isPlaying = true;
                animate();
            }
        }

        function addToTimeline() {
            const rayConfig = {
                headSize: parseInt(document.getElementById('headSize').value),
                origin: {
                    x: parseInt(document.getElementById('originX').value),
                    y: parseInt(document.getElementById('originY').value)
                },
                target: {
                    x: parseInt(document.getElementById('targetX').value),
                    y: parseInt(document.getElementById('targetY').value)
                },
                headColor: document.getElementById('headColor').value,
                trailColor: document.getElementById('trailColor').value,
                duration: parseInt(document.getElementById('duration').value),
                delay: parseInt(document.getElementById('delay').value)
            };
            
            timeline.push(rayConfig);
            updateTimelineUI();
        }

        function updateTimelineUI() {
            const timelineEl = document.getElementById('timeline');
            timelineEl.innerHTML = '';
            
            timeline.forEach((ray, index) => {
                const item = document.createElement('div');
                item.className = 'timeline-item';
                item.innerHTML = `
                    <div>
                        Ray ${index + 1}: 
                        (${ray.origin.x},${ray.origin.y}) â†’ (${ray.target.x},${ray.target.y})
                        <span class="color-preview" style="background: ${ray.headColor}"></span>
                    </div>
                    <button onclick="removeFromTimeline(${index})">Remove</button>
                `;
                timelineEl.appendChild(item);
            });
            
            updateJsonOutput();
        }

        function removeFromTimeline(index) {
            timeline.splice(index, 1);
            updateTimelineUI();
        }

        function playTimeline() {
            clearGrid();
            activeRays = timeline.map(config => new Ray({
                ...config,
                headColor: parseInt(config.headColor.slice(1), 16),
                trailColor: config.trailColor ? parseInt(config.trailColor.slice(1), 16) : false
            }));
            
            startTime = Date.now();
            isPlaying = true;
            activeRays.forEach(ray => setTimeout(() => ray.start(), ray.delay));
            animate();
        }

        function animate() {
            if (!isPlaying) return;

            const currentTime = Date.now();
            const delta = currentTime - startTime;
            startTime = currentTime;

            const stillActive = activeRays.some(ray => ray.update(delta));

            if (stillActive) {
                requestAnimationFrame(animate);
            } else {
                isPlaying = false;
            }
        }

        function clearGrid() {
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = cells[y][x];
                    cell.graphics.clear();
                    cell.graphics.beginFill(0x333333);
                    cell.graphics.drawRect(0, 0, CELL_SIZE, CELL_SIZE);
                    cell.graphics.endFill();
                }
            }
        }

        function clearPreview() {
            clearGrid();
            isPlaying = false;
            activeRays = [];
        }

        function clearTimeline() {
            timeline = [];
            updateTimelineUI();
        }

        function exportTimeline() {
            const json = JSON.stringify(timeline, null, 2);
            document.getElementById('jsonOutput').value = json;
        }

        function updateJsonOutput() {
            const json = JSON.stringify(timeline, null, 2);
            document.getElementById('jsonOutput').value = json;
        }
        initializeShapeSelector();
    </script>
</body>
</html>